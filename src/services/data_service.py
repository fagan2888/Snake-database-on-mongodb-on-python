from data.owners import Owner
from data.cages import Cage
from data.bookings import Booking
from data.snakes import Snake
from typing import List, Optional


import datetime
import bson


def create_account(name: str, email: str) -> Owner:  # returns Owner type
    owner = Owner() #this doesn't create an id (if you have not)
    owner.name = name
    owner.email = email
    owner.save()  # this function saves the document on database with autogenerated key
    #this creates an _id if user has not defined already and if this is the first time you are saving this
    return owner


def find_account_by_email(email):
    owner = Owner.objects(email=email).first()
    return owner

def register_cage(active_account,name,price,allow_dangerous,has_toys,carpeted,meters) -> Cage:
    cage = Cage()
    cage.name = name
    cage.square_meters = meters
    cage.is_carpeted = carpeted
    cage.has_toys = has_toys
    cage.allow_dangerous_snakes = allow_dangerous
    cage.price = price

    cage.save()  # stores it in the database

    account = find_account_by_email(active_account.email)  # we don't have any stale data
    account.cage_ids.append(cage.id) #adding the new cage id
    account.save() #push the changes back to database

    return cage

def find_cages_for_user(account):
    # query = Cage.objects(email=account.email) #checking with mail.
# go to id of the cage $operator
    return list(Cage.objects(id__in=account.cage_ids))

def add_available_date(cage: Cage,
                       start_date: datetime.datetime, days: int) -> Cage:
    booking = Booking()
    booking.check_in_date = start_date
    booking.check_out_date = start_date + datetime.timedelta(days=days)

    cage = Cage.objects(id=cage.id).first() #get the cage
    cage.bookings.append(booking) #booking is added to cage as it as embedded document
    cage.save()

    return cage

def add_snake(account, name, length, species, is_venomous) -> Snake:
    snake = Snake()
    snake.name = name
    snake.length = length
    snake.species = species
    snake.is_venomous = is_venomous
    snake.save()

    owner = find_account_by_email(account.email)
    owner.snake_ids.append(snake.id)
    owner.save()

    return snake


def get_snakes_for_user(user_id: bson.ObjectId) -> list:
    owner = Owner.objects(id=user_id).first()
    snakes = Snake.objects(id__in=owner.snake_ids).all()

    return list(snakes)

def get_available_cages(checkin: datetime.datetime,
                        checkout: datetime.datetime, snake: Snake) -> list:
    min_size = snake.length / 4

    '''#in cage objects #greater than $gt  #less than(before) $lt'''
    query = Cage.objects() \
        .filter(square_meters__gte=min_size) \
        .filter(bookings__check_in_date__lte=checkin) \
        .filter(bookings__check_out_date__gte=checkout)

    if snake.is_venomous:# one more filter only if dangerous snakes are there
        query = query.filter(allow_dangerous_snakes=True)

    cages = query.order_by('price', '-square_meters') #order by price and square meters

    final_cages = []
    for c in cages: #$element_match. The earlier filter was to individually see checkin dates, but what we want is both checkin and checkout are from single instance
        for b in c.bookings:
            if b.check_in_date <= checkin and b.check_out_date >= checkout and b.guest_snake_id is None:
                final_cages.append(c)

    return final_cages

def book_cage(account, snake, cage, checkin, checkout):
    booking: Optional[Booking] = None

    for b in cage.bookings:
        if b.check_in_date <= checkin and b.check_out_date >= checkout and b.guest_snake_id is None:
            booking = b
            break

    booking.guest_owner_id = account.id
    booking.guest_snake_id = snake.id
    booking.check_in_date = checkin
    booking.check_out_date = checkout
    booking.booked_date = datetime.datetime.now()

    cage.save()


def get_bookings_for_user(email: str) -> List[Booking]:
    account = find_account_by_email(email)
    #looking in heirarchy
    # look at guest_owner_id from bookings (embedded in cages) __ to navigate to levels and also for dollar operato
    booked_cages = Cage.objects() \
        .filter(bookings__guest_owner_id=account.id) \
        .only('bookings', 'name')#only want bookings and cage name

    def map_cage_to_booking(cage, booking):
        booking.cage = cage
        return booking

    bookings = [
        map_cage_to_booking(cage, booking)
        for cage in booked_cages
        for booking in cage.bookings
        if booking.guest_owner_id == account.id
    ]

    return bookings


"""Other commands"""

"""Update atomically"""
# Cage.objects(id==cage_id).update_one(inc__number_of_stays = 1)
#num_updated = Owner.objects(email=email).update_one(push__snake_ids = snake.id)